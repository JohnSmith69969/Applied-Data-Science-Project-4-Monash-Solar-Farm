{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": 1,
      "id": "28a7d93d",
      "metadata": {
        "id": "28a7d93d"
      },
      "outputs": [],
      "source": [
        "from datetime import datetime\n",
        "from distutils.util import strtobool\n",
        "\n",
        "import pandas as pd\n",
        "\n",
        "\n",
        "\n",
        "# Converts the contents in a .tsf file into a dataframe and returns it along with other meta-data of the dataset: frequency, horizon, whether the dataset contains missing values and whether the series have equal lengths\n",
        "#\n",
        "# Parameters\n",
        "# full_file_path_and_name - complete .tsf file path\n",
        "# replace_missing_vals_with - a term to indicate the missing values in series in the returning dataframe\n",
        "# value_column_name - Any name that is preferred to have as the name of the column containing series values in the returning dataframe\n",
        "def convert_tsf_to_dataframe(\n",
        "    full_file_path_and_name,\n",
        "    replace_missing_vals_with=\"NaN\",\n",
        "    value_column_name=\"series_value\",\n",
        "):\n",
        "    col_names = []\n",
        "    col_types = []\n",
        "    all_data = {}\n",
        "    line_count = 0\n",
        "    frequency = None\n",
        "    forecast_horizon = None\n",
        "    contain_missing_values = None\n",
        "    contain_equal_length = None\n",
        "    found_data_tag = False\n",
        "    found_data_section = False\n",
        "    started_reading_data_section = False\n",
        "\n",
        "    with open(full_file_path_and_name, \"r\", encoding=\"cp1252\") as file:\n",
        "        for line in file:\n",
        "            # Strip white space from start/end of line\n",
        "            line = line.strip()\n",
        "\n",
        "            if line:\n",
        "                if line.startswith(\"@\"):  # Read meta-data\n",
        "                    if not line.startswith(\"@data\"):\n",
        "                        line_content = line.split(\" \")\n",
        "                        if line.startswith(\"@attribute\"):\n",
        "                            if (\n",
        "                                len(line_content) != 3\n",
        "                            ):  # Attributes have both name and type\n",
        "                                raise Exception(\"Invalid meta-data specification.\")\n",
        "\n",
        "                            col_names.append(line_content[1])\n",
        "                            col_types.append(line_content[2])\n",
        "                        else:\n",
        "                            if (\n",
        "                                len(line_content) != 2\n",
        "                            ):  # Other meta-data have only values\n",
        "                                raise Exception(\"Invalid meta-data specification.\")\n",
        "\n",
        "                            if line.startswith(\"@frequency\"):\n",
        "                                frequency = line_content[1]\n",
        "                            elif line.startswith(\"@horizon\"):\n",
        "                                forecast_horizon = int(line_content[1])\n",
        "                            elif line.startswith(\"@missing\"):\n",
        "                                contain_missing_values = bool(\n",
        "                                    strtobool(line_content[1])\n",
        "                                )\n",
        "                            elif line.startswith(\"@equallength\"):\n",
        "                                contain_equal_length = bool(strtobool(line_content[1]))\n",
        "\n",
        "                    else:\n",
        "                        if len(col_names) == 0:\n",
        "                            raise Exception(\n",
        "                                \"Missing attribute section. Attribute section must come before data.\"\n",
        "                            )\n",
        "\n",
        "                        found_data_tag = True\n",
        "                elif not line.startswith(\"#\"):\n",
        "                    if len(col_names) == 0:\n",
        "                        raise Exception(\n",
        "                            \"Missing attribute section. Attribute section must come before data.\"\n",
        "                        )\n",
        "                    elif not found_data_tag:\n",
        "                        raise Exception(\"Missing @data tag.\")\n",
        "                    else:\n",
        "                        if not started_reading_data_section:\n",
        "                            started_reading_data_section = True\n",
        "                            found_data_section = True\n",
        "                            all_series = []\n",
        "\n",
        "                            for col in col_names:\n",
        "                                all_data[col] = []\n",
        "\n",
        "                        full_info = line.split(\":\")\n",
        "\n",
        "                        if len(full_info) != (len(col_names) + 1):\n",
        "                            raise Exception(\"Missing attributes/values in series.\")\n",
        "\n",
        "                        series = full_info[len(full_info) - 1]\n",
        "                        series = series.split(\",\")\n",
        "\n",
        "                        if len(series) == 0:\n",
        "                            raise Exception(\n",
        "                                \"A given series should contains a set of comma separated numeric values. At least one numeric value should be there in a series. Missing values should be indicated with ? symbol\"\n",
        "                            )\n",
        "\n",
        "                        numeric_series = []\n",
        "\n",
        "                        for val in series:\n",
        "                            if val == \"?\":\n",
        "                                numeric_series.append(replace_missing_vals_with)\n",
        "                            else:\n",
        "                                numeric_series.append(float(val))\n",
        "\n",
        "                        if numeric_series.count(replace_missing_vals_with) == len(\n",
        "                            numeric_series\n",
        "                        ):\n",
        "                            raise Exception(\n",
        "                                \"All series values are missing. A given series should contains a set of comma separated numeric values. At least one numeric value should be there in a series.\"\n",
        "                            )\n",
        "\n",
        "                        all_series.append(pd.Series(numeric_series).array)\n",
        "\n",
        "                        for i in range(len(col_names)):\n",
        "                            att_val = None\n",
        "                            if col_types[i] == \"numeric\":\n",
        "                                att_val = int(full_info[i])\n",
        "                            elif col_types[i] == \"string\":\n",
        "                                att_val = str(full_info[i])\n",
        "                            elif col_types[i] == \"date\":\n",
        "                                att_val = datetime.strptime(\n",
        "                                    full_info[i], \"%Y-%m-%d %H-%M-%S\"\n",
        "                                )\n",
        "                            else:\n",
        "                                raise Exception(\n",
        "                                    \"Invalid attribute type.\"\n",
        "                                )  # Currently, the code supports only numeric, string and date types. Extend this as required.\n",
        "\n",
        "                            if att_val is None:\n",
        "                                raise Exception(\"Invalid attribute value.\")\n",
        "                            else:\n",
        "                                all_data[col_names[i]].append(att_val)\n",
        "\n",
        "                line_count = line_count + 1\n",
        "\n",
        "        if line_count == 0:\n",
        "            raise Exception(\"Empty file.\")\n",
        "        if len(col_names) == 0:\n",
        "            raise Exception(\"Missing attribute section.\")\n",
        "        if not found_data_section:\n",
        "            raise Exception(\"Missing series information under data section.\")\n",
        "\n",
        "        all_data[value_column_name] = all_series\n",
        "        loaded_data = pd.DataFrame(all_data)\n",
        "\n",
        "        return (\n",
        "            loaded_data,\n",
        "            frequency,\n",
        "            forecast_horizon,\n",
        "            contain_missing_values,\n",
        "            contain_equal_length,\n",
        "        )\n",
        "\n",
        "\n",
        "#loaded_data, frequency, forecast_horizon, contain_missing_values, contain_equal_length = convert_tsf_to_dataframe(\"TSForecasting/tsf_data/sample.tsf\")\n",
        "\n",
        "#print(loaded_data)\n",
        "#print(frequency)\n",
        "#print(forecast_horizon)\n",
        "#print(contain_missing_values)\n",
        "#print(contain_equal_length)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 2,
      "id": "92159c72",
      "metadata": {
        "scrolled": false,
        "id": "92159c72",
        "outputId": "d95ab276-6ac5-46bb-8aea-25217f1d0368",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 315
        }
      },
      "outputs": [
        {
          "output_type": "error",
          "ename": "FileNotFoundError",
          "evalue": "ignored",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
            "\u001b[0;32m<ipython-input-2-c5c0a647142b>\u001b[0m in \u001b[0;36m<cell line: 1>\u001b[0;34m()\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mPhase_1\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mconvert_tsf_to_dataframe\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"phase_1_data.tsf\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      2\u001b[0m \u001b[0mPhase_1\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m<ipython-input-1-24362cedd588>\u001b[0m in \u001b[0;36mconvert_tsf_to_dataframe\u001b[0;34m(full_file_path_and_name, replace_missing_vals_with, value_column_name)\u001b[0m\n\u001b[1;32m     29\u001b[0m     \u001b[0mstarted_reading_data_section\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     30\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 31\u001b[0;31m     \u001b[0;32mwith\u001b[0m \u001b[0mopen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfull_file_path_and_name\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"r\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mencoding\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\"cp1252\"\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mfile\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     32\u001b[0m         \u001b[0;32mfor\u001b[0m \u001b[0mline\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mfile\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     33\u001b[0m             \u001b[0;31m# Strip white space from start/end of line\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] No such file or directory: 'phase_1_data.tsf'"
          ]
        }
      ],
      "source": [
        "Phase_1 = convert_tsf_to_dataframe(\"phase_1_data.tsf\")\n",
        "Phase_1"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "31c62886",
      "metadata": {
        "id": "31c62886"
      },
      "outputs": [],
      "source": [
        "loaded_data, frequency, forecast_horizon, contain_missing_values, contain_equal_length = Phase_1"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "da785ff1",
      "metadata": {
        "id": "da785ff1"
      },
      "outputs": [],
      "source": [
        "loaded_data"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0931839f",
      "metadata": {
        "scrolled": false,
        "id": "0931839f"
      },
      "outputs": [],
      "source": [
        "dataset = loaded_data.explode('series_value')\n",
        "dataset"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "3234da4b",
      "metadata": {
        "id": "3234da4b"
      },
      "source": [
        "## Building 0"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "54240995",
      "metadata": {
        "id": "54240995"
      },
      "outputs": [],
      "source": [
        "building_0 = dataset.loc[dataset['series_name']=='Building0']\n",
        "building_0"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "843a9528",
      "metadata": {
        "id": "843a9528"
      },
      "outputs": [],
      "source": [
        "import datetime\n",
        "\n",
        "# Input start date\n",
        "start_date_str = '3/7/2016 21:30:00'\n",
        "start_date = datetime.datetime.strptime(start_date_str, '%d/%m/%Y %H:%M:%S')\n",
        "\n",
        "# Interval duration\n",
        "interval_duration = datetime.timedelta(minutes=15)\n",
        "\n",
        "# Number of intervals\n",
        "num_intervals = len(loaded_data['series_value'][0])\n",
        "\n",
        "# Calculate the end date\n",
        "end_date = start_date + interval_duration * (num_intervals-1)\n",
        "\n",
        "# Print the end date\n",
        "print(\"End Date:\", end_date.strftime('%d/%m/%Y %H:%M:%S'))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "643feebf",
      "metadata": {
        "id": "643feebf"
      },
      "outputs": [],
      "source": [
        "end_date_str = '30/09/2020 23:45:00'\n",
        "\n",
        "# Convert start and end date strings to datetime objects\n",
        "end_date = datetime.datetime.strptime(end_date_str, '%d/%m/%Y %H:%M:%S')\n",
        "\n",
        "# Create a column of datetime values between start and end date with a frequency of 15 minutes\n",
        "datetime_column = pd.date_range(start=start_date, end=end_date, freq='15T')\n",
        "\n",
        "\n",
        "building_0['start_timestamp']=datetime_column"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "62cc3155",
      "metadata": {
        "scrolled": false,
        "id": "62cc3155"
      },
      "outputs": [],
      "source": [
        "building_0"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "678ea1cd",
      "metadata": {
        "id": "678ea1cd"
      },
      "outputs": [],
      "source": [
        "building_0 = building_0.rename(columns={\"series_name\": \"building_no\", \"start_timestamp\": \"timestamp\",\"series_value\":\"energy_demand\"})"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "aa20d749",
      "metadata": {
        "id": "aa20d749"
      },
      "outputs": [],
      "source": [
        "building_0.dtypes"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0e7c87b5",
      "metadata": {
        "id": "0e7c87b5"
      },
      "outputs": [],
      "source": [
        "building_0 = building_0[building_0.energy_demand != \"NaN\"]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "365ecb9f",
      "metadata": {
        "id": "365ecb9f"
      },
      "outputs": [],
      "source": [
        "building_0[\"energy_demand\"] = pd.to_numeric(building_0[\"energy_demand\"])\n",
        "building_0"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "536befd3",
      "metadata": {
        "id": "536befd3"
      },
      "source": [
        "## Building 1"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6534bc50",
      "metadata": {
        "scrolled": false,
        "id": "6534bc50"
      },
      "outputs": [],
      "source": [
        "building_1 = dataset.loc[dataset['series_name']=='Building1']\n",
        "building_1"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9e507e27",
      "metadata": {
        "id": "9e507e27"
      },
      "outputs": [],
      "source": [
        "import datetime\n",
        "\n",
        "# Input start date\n",
        "start_date_str = '09/01/2016 23:15:00'\n",
        "start_date = datetime.datetime.strptime(start_date_str, '%d/%m/%Y %H:%M:%S')\n",
        "\n",
        "# Interval duration\n",
        "interval_duration = datetime.timedelta(minutes=15)\n",
        "\n",
        "# Number of intervals\n",
        "num_intervals = len(loaded_data['series_value'][1])\n",
        "\n",
        "# Calculate the end date\n",
        "end_date = start_date + interval_duration * (num_intervals-1)\n",
        "\n",
        "# Print the end date\n",
        "print(\"End Date:\", end_date.strftime('%d/%m/%Y %H:%M:%S'))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8b827ea5",
      "metadata": {
        "id": "8b827ea5"
      },
      "outputs": [],
      "source": [
        "end_date_str = '30/09/2017 23:45:00'\n",
        "\n",
        "# Convert start and end date strings to datetime objects\n",
        "end_date = pd.to_datetime(end_date_str)\n",
        "\n",
        "# Create a column of datetime values between start and end date with a frequency of 15 minutes\n",
        "datetime_column = pd.date_range(start=start_date, end=end_date, freq='15T')\n",
        "\n",
        "#building_0['start_timestamp']=datetime_column\n",
        "building_1['start_timestamp']=datetime_column"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2fa177b2",
      "metadata": {
        "scrolled": false,
        "id": "2fa177b2"
      },
      "outputs": [],
      "source": [
        "building_1"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "33a54f12",
      "metadata": {
        "id": "33a54f12"
      },
      "outputs": [],
      "source": [
        "building_1 = building_1.rename(columns={\"series_name\": \"building_no\", \"start_timestamp\": \"timestamp\",\"series_value\":\"energy_demand\"})"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "ea27f960",
      "metadata": {
        "id": "ea27f960"
      },
      "outputs": [],
      "source": [
        "building_1 = building_1[building_1.energy_demand != \"NaN\"]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a445feae",
      "metadata": {
        "id": "a445feae"
      },
      "outputs": [],
      "source": [
        "building_1[\"energy_demand\"] = pd.to_numeric(building_1[\"energy_demand\"])\n",
        "building_1"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "1ad63dc7",
      "metadata": {
        "id": "1ad63dc7"
      },
      "source": [
        "## Building 3"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "34ee3a96",
      "metadata": {
        "scrolled": false,
        "id": "34ee3a96"
      },
      "outputs": [],
      "source": [
        "building_3 = dataset.loc[dataset['series_name']=='Building3']\n",
        "building_3"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d7cdb7cf",
      "metadata": {
        "id": "d7cdb7cf"
      },
      "outputs": [],
      "source": [
        "import datetime\n",
        "\n",
        "# Input start date\n",
        "start_date_str = '01/03/2016 04:15:00'\n",
        "start_date = datetime.datetime.strptime(start_date_str, '%d/%m/%Y %H:%M:%S')\n",
        "\n",
        "# Interval duration\n",
        "interval_duration = datetime.timedelta(minutes=15)\n",
        "\n",
        "# Number of intervals\n",
        "num_intervals = len(loaded_data['series_value'][2])\n",
        "\n",
        "# Calculate the end date\n",
        "end_date = start_date + interval_duration * (num_intervals-1)\n",
        "\n",
        "# Print the end date\n",
        "print(\"End Date:\", end_date.strftime('%d/%m/%Y %H:%M:%S'))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9bd60757",
      "metadata": {
        "id": "9bd60757"
      },
      "outputs": [],
      "source": [
        "end_date_str = '30/09/2020 23:45:00'\n",
        "\n",
        "# Convert start and end date strings to datetime objects\n",
        "end_date = pd.to_datetime(end_date_str)\n",
        "\n",
        "# Create a column of datetime values between start and end date with a frequency of 15 minutes\n",
        "datetime_column = pd.date_range(start=start_date, end=end_date, freq='15T')\n",
        "\n",
        "#building_0['start_timestamp']=datetime_column\n",
        "building_3['start_timestamp']=datetime_column"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "091b09f1",
      "metadata": {
        "id": "091b09f1"
      },
      "outputs": [],
      "source": [
        "building_3 = building_3.rename(columns={\"series_name\": \"building_no\", \"start_timestamp\": \"timestamp\",\"series_value\":\"energy_demand\"})"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9e0faf9a",
      "metadata": {
        "id": "9e0faf9a"
      },
      "outputs": [],
      "source": [
        "building_3 = building_3[building_3.energy_demand != \"NaN\"]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "36e543da",
      "metadata": {
        "id": "36e543da"
      },
      "outputs": [],
      "source": [
        "building_3[\"energy_demand\"] = pd.to_numeric(building_3[\"energy_demand\"])\n",
        "building_3"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "f2aeed3e",
      "metadata": {
        "id": "f2aeed3e"
      },
      "source": [
        "## Building 4"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e180fca8",
      "metadata": {
        "id": "e180fca8"
      },
      "outputs": [],
      "source": [
        "building_4 = dataset.loc[dataset['series_name']=='Building4']\n",
        "building_4"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a25a2442",
      "metadata": {
        "id": "a25a2442"
      },
      "outputs": [],
      "source": [
        "import datetime\n",
        "\n",
        "# Input start date\n",
        "start_date_str = '03/07/2019 04:45:00'\n",
        "start_date = datetime.datetime.strptime(start_date_str, '%d/%m/%Y %H:%M:%S')\n",
        "\n",
        "# Interval duration\n",
        "interval_duration = datetime.timedelta(minutes=15)\n",
        "\n",
        "# Number of intervals\n",
        "num_intervals = len(loaded_data['series_value'][3])\n",
        "\n",
        "# Calculate the end date\n",
        "end_date = start_date + interval_duration * (num_intervals-1)\n",
        "\n",
        "# Print the end date\n",
        "print(\"End Date:\", end_date.strftime('%d/%m/%Y %H:%M:%S'))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f57d9267",
      "metadata": {
        "id": "f57d9267"
      },
      "outputs": [],
      "source": [
        "end_date_str = '30/09/2020 23:45:00'\n",
        "\n",
        "# Convert start and end date strings to datetime objects\n",
        "end_date = pd.to_datetime(end_date_str)\n",
        "\n",
        "# Create a column of datetime values between start and end date with a frequency of 15 minutes\n",
        "datetime_column = pd.date_range(start=start_date, end=end_date, freq='15T')\n",
        "\n",
        "#building_0['start_timestamp']=datetime_column\n",
        "building_4['start_timestamp']=datetime_column"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "755d5047",
      "metadata": {
        "id": "755d5047"
      },
      "outputs": [],
      "source": [
        "building_4 = building_4.rename(columns={\"series_name\": \"building_no\", \"start_timestamp\": \"timestamp\",\"series_value\":\"energy_demand\"})"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "568a5a89",
      "metadata": {
        "id": "568a5a89"
      },
      "outputs": [],
      "source": [
        "building_4 = building_4[building_4.energy_demand != \"NaN\"]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7c7e3dd2",
      "metadata": {
        "id": "7c7e3dd2"
      },
      "outputs": [],
      "source": [
        "building_4[\"energy_demand\"] = pd.to_numeric(building_4[\"energy_demand\"])\n",
        "building_4"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "f1e28c4c",
      "metadata": {
        "id": "f1e28c4c"
      },
      "source": [
        "## Building 5"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5905f865",
      "metadata": {
        "id": "5905f865"
      },
      "outputs": [],
      "source": [
        "building_5 = dataset.loc[dataset['series_name']=='Building5']\n",
        "building_5"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "330c22bd",
      "metadata": {
        "id": "330c22bd"
      },
      "outputs": [],
      "source": [
        "import datetime\n",
        "\n",
        "# Input start date\n",
        "start_date_str = '25/07/2019 23:00:00'\n",
        "start_date = datetime.datetime.strptime(start_date_str, '%d/%m/%Y %H:%M:%S')\n",
        "\n",
        "# Interval duration\n",
        "interval_duration = datetime.timedelta(minutes=15)\n",
        "\n",
        "# Number of intervals\n",
        "num_intervals = len(loaded_data['series_value'][4])\n",
        "\n",
        "# Calculate the end date\n",
        "end_date = start_date + interval_duration * (num_intervals-1)\n",
        "\n",
        "# Print the end date\n",
        "print(\"End Date:\", end_date.strftime('%d/%m/%Y %H:%M:%S'))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a460c484",
      "metadata": {
        "id": "a460c484"
      },
      "outputs": [],
      "source": [
        "end_date_str = '30/09/2020 23:45:00'\n",
        "\n",
        "# Convert start and end date strings to datetime objects\n",
        "end_date = pd.to_datetime(end_date_str)\n",
        "\n",
        "# Create a column of datetime values between start and end date with a frequency of 15 minutes\n",
        "datetime_column = pd.date_range(start=start_date, end=end_date, freq='15T')\n",
        "\n",
        "#building_0['start_timestamp']=datetime_column\n",
        "building_5['start_timestamp']=datetime_column"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "674790f0",
      "metadata": {
        "id": "674790f0"
      },
      "outputs": [],
      "source": [
        "building_5 = building_5.rename(columns={\"series_name\": \"building_no\", \"start_timestamp\": \"timestamp\",\"series_value\":\"energy_demand\"})"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e52d21a4",
      "metadata": {
        "id": "e52d21a4"
      },
      "outputs": [],
      "source": [
        "building_5 = building_5[building_5.energy_demand != \"NaN\"]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a8d7b060",
      "metadata": {
        "id": "a8d7b060"
      },
      "outputs": [],
      "source": [
        "building_5[\"energy_demand\"] = pd.to_numeric(building_5[\"energy_demand\"])\n",
        "building_5"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "6aee1b07",
      "metadata": {
        "id": "6aee1b07"
      },
      "source": [
        "## Building 6"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0b8a21be",
      "metadata": {
        "id": "0b8a21be"
      },
      "outputs": [],
      "source": [
        "building_6 = dataset.loc[dataset['series_name']=='Building6']\n",
        "building_6"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e554fabc",
      "metadata": {
        "id": "e554fabc"
      },
      "outputs": [],
      "source": [
        "import datetime\n",
        "\n",
        "# Input start date\n",
        "start_date_str = '25/07/2019 01:45:00'\n",
        "start_date = datetime.datetime.strptime(start_date_str, '%d/%m/%Y %H:%M:%S')\n",
        "\n",
        "# Interval duration\n",
        "interval_duration = datetime.timedelta(minutes=15)\n",
        "\n",
        "# Number of intervals\n",
        "num_intervals = len(loaded_data['series_value'][5])\n",
        "\n",
        "# Calculate the end date\n",
        "end_date = start_date + interval_duration * (num_intervals-1)\n",
        "\n",
        "# Print the end date\n",
        "print(\"End Date:\", end_date.strftime('%d/%m/%Y %H:%M:%S'))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2084157a",
      "metadata": {
        "id": "2084157a"
      },
      "outputs": [],
      "source": [
        "end_date_str = '30/09/2020 23:45:00'\n",
        "\n",
        "# Convert start and end date strings to datetime objects\n",
        "end_date = pd.to_datetime(end_date_str)\n",
        "\n",
        "# Create a column of datetime values between start and end date with a frequency of 15 minutes\n",
        "datetime_column = pd.date_range(start=start_date, end=end_date, freq='15T')\n",
        "\n",
        "#building_0['start_timestamp']=datetime_column\n",
        "building_6['start_timestamp']=datetime_column"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "063b8bd2",
      "metadata": {
        "id": "063b8bd2"
      },
      "outputs": [],
      "source": [
        "building_6 = building_6.rename(columns={\"series_name\": \"building_no\", \"start_timestamp\": \"timestamp\",\"series_value\":\"energy_demand\"})"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c81ec8c8",
      "metadata": {
        "id": "c81ec8c8"
      },
      "outputs": [],
      "source": [
        "building_6 = building_6[building_6.energy_demand != \"NaN\"]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b1d2f6fc",
      "metadata": {
        "id": "b1d2f6fc"
      },
      "outputs": [],
      "source": [
        "building_6[\"energy_demand\"] = pd.to_numeric(building_6[\"energy_demand\"])\n",
        "building_6"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "41edbb8a",
      "metadata": {
        "id": "41edbb8a"
      },
      "source": [
        "## Solar 0"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "56774fad",
      "metadata": {
        "id": "56774fad"
      },
      "outputs": [],
      "source": [
        "solar_0 = dataset.loc[dataset['series_name']=='Solar0']\n",
        "solar_0"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6dbbe262",
      "metadata": {
        "id": "6dbbe262"
      },
      "outputs": [],
      "source": [
        "import datetime\n",
        "\n",
        "# Input start date\n",
        "start_date_str = '25/04/2020 14:00:00'\n",
        "start_date = datetime.datetime.strptime(start_date_str, '%d/%m/%Y %H:%M:%S')\n",
        "\n",
        "# Interval duration\n",
        "interval_duration = datetime.timedelta(minutes=15)\n",
        "\n",
        "# Number of intervals\n",
        "num_intervals = len(loaded_data['series_value'][6])\n",
        "\n",
        "# Calculate the end date\n",
        "end_date = start_date + interval_duration * (num_intervals-1)\n",
        "\n",
        "# Print the end date\n",
        "print(\"End Date:\", end_date.strftime('%d/%m/%Y %H:%M:%S'))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c4a3a9c6",
      "metadata": {
        "id": "c4a3a9c6"
      },
      "outputs": [],
      "source": [
        "end_date_str = '30/09/2020 23:45:00'\n",
        "\n",
        "# Convert start and end date strings to datetime objects\n",
        "end_date = pd.to_datetime(end_date_str)\n",
        "\n",
        "# Create a column of datetime values between start and end date with a frequency of 15 minutes\n",
        "datetime_column = pd.date_range(start=start_date, end=end_date, freq='15T')\n",
        "\n",
        "#building_0['start_timestamp']=datetime_column\n",
        "solar_0['start_timestamp']=datetime_column"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "1c5e59ec",
      "metadata": {
        "id": "1c5e59ec"
      },
      "outputs": [],
      "source": [
        "solar_0 = solar_0.rename(columns={\"series_name\": \"solar_no\", \"start_timestamp\": \"timestamp\",\"series_value\":\"power_output\"})"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8b5d6bd0",
      "metadata": {
        "id": "8b5d6bd0"
      },
      "outputs": [],
      "source": [
        "solar_0 = solar_0[solar_0.power_output != \"NaN\"]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "1ce7e328",
      "metadata": {
        "id": "1ce7e328"
      },
      "outputs": [],
      "source": [
        "solar_0[\"power_output\"] = pd.to_numeric(solar_0[\"power_output\"])\n",
        "solar_0"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "8bf15f2a",
      "metadata": {
        "id": "8bf15f2a"
      },
      "source": [
        "## Solar 1"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "fcd64cb0",
      "metadata": {
        "id": "fcd64cb0"
      },
      "outputs": [],
      "source": [
        "solar_1 = dataset.loc[dataset['series_name']=='Solar1']\n",
        "solar_1"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "67e22907",
      "metadata": {
        "id": "67e22907"
      },
      "outputs": [],
      "source": [
        "import datetime\n",
        "\n",
        "# Input start date\n",
        "start_date_str = '31/12/2018 13:00:00'\n",
        "start_date = datetime.datetime.strptime(start_date_str, '%d/%m/%Y %H:%M:%S')\n",
        "\n",
        "# Interval duration\n",
        "interval_duration = datetime.timedelta(minutes=15)\n",
        "\n",
        "# Number of intervals\n",
        "num_intervals = len(loaded_data['series_value'][7])\n",
        "\n",
        "# Calculate the end date\n",
        "end_date = start_date + interval_duration * (num_intervals-1)\n",
        "\n",
        "# Print the end date\n",
        "print(\"End Date:\", end_date.strftime('%d/%m/%Y %H:%M:%S'))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4f97be23",
      "metadata": {
        "id": "4f97be23"
      },
      "outputs": [],
      "source": [
        "end_date_str = '30/09/2020 23:45:00'\n",
        "\n",
        "# Convert start and end date strings to datetime objects\n",
        "end_date = pd.to_datetime(end_date_str)\n",
        "\n",
        "# Create a column of datetime values between start and end date with a frequency of 15 minutes\n",
        "datetime_column = pd.date_range(start=start_date, end=end_date, freq='15T')\n",
        "\n",
        "#building_0['start_timestamp']=datetime_column\n",
        "solar_1['start_timestamp']=datetime_column"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cbb07e38",
      "metadata": {
        "id": "cbb07e38"
      },
      "outputs": [],
      "source": [
        "solar_1 = solar_1.rename(columns={\"series_name\": \"solar_no\", \"start_timestamp\": \"timestamp\",\"series_value\":\"power_output\"})"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "00239953",
      "metadata": {
        "id": "00239953"
      },
      "outputs": [],
      "source": [
        "solar_1 = solar_1[solar_1.power_output != \"NaN\"]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "588336f5",
      "metadata": {
        "id": "588336f5"
      },
      "outputs": [],
      "source": [
        "solar_1[\"power_output\"] = pd.to_numeric(solar_1[\"power_output\"])\n",
        "solar_1"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "6462733b",
      "metadata": {
        "id": "6462733b"
      },
      "source": [
        "## Solar 2"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0a6affc1",
      "metadata": {
        "id": "0a6affc1"
      },
      "outputs": [],
      "source": [
        "solar_2 = dataset.loc[dataset['series_name']=='Solar2']\n",
        "solar_2"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d31e4cd6",
      "metadata": {
        "id": "d31e4cd6"
      },
      "outputs": [],
      "source": [
        "import datetime\n",
        "\n",
        "# Input start date\n",
        "start_date_str = '05/06/2019 14:00:00'\n",
        "start_date = datetime.datetime.strptime(start_date_str, '%d/%m/%Y %H:%M:%S')\n",
        "\n",
        "# Interval duration\n",
        "interval_duration = datetime.timedelta(minutes=15)\n",
        "\n",
        "# Number of intervals\n",
        "num_intervals = len(loaded_data['series_value'][8])\n",
        "\n",
        "# Calculate the end date\n",
        "end_date = start_date + interval_duration * (num_intervals-1)\n",
        "\n",
        "# Print the end date\n",
        "print(\"End Date:\", end_date.strftime('%d/%m/%Y %H:%M:%S'))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "bfea6f64",
      "metadata": {
        "id": "bfea6f64"
      },
      "outputs": [],
      "source": [
        "end_date_str = '30/09/2020 23:45:00'\n",
        "\n",
        "# Convert start and end date strings to datetime objects\n",
        "end_date = pd.to_datetime(end_date_str)\n",
        "\n",
        "# Create a column of datetime values between start and end date with a frequency of 15 minutes\n",
        "datetime_column = pd.date_range(start=start_date, end=end_date, freq='15T')\n",
        "\n",
        "#building_0['start_timestamp']=datetime_column\n",
        "solar_2['start_timestamp']=datetime_column"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6d119dad",
      "metadata": {
        "id": "6d119dad"
      },
      "outputs": [],
      "source": [
        "solar_2 = solar_2.rename(columns={\"series_name\": \"solar_no\", \"start_timestamp\": \"timestamp\",\"series_value\":\"power_output\"})"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "851a210b",
      "metadata": {
        "id": "851a210b"
      },
      "outputs": [],
      "source": [
        "solar_2 = solar_2[solar_2.power_output != \"NaN\"]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9b18d88c",
      "metadata": {
        "id": "9b18d88c"
      },
      "outputs": [],
      "source": [
        "solar_2[\"power_output\"] = pd.to_numeric(solar_2[\"power_output\"])\n",
        "solar_2"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "5e430f74",
      "metadata": {
        "id": "5e430f74"
      },
      "source": [
        "## Solar 3"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5e34282c",
      "metadata": {
        "id": "5e34282c"
      },
      "outputs": [],
      "source": [
        "solar_3 = dataset.loc[dataset['series_name']=='Solar3']\n",
        "solar_3"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5d002680",
      "metadata": {
        "id": "5d002680"
      },
      "outputs": [],
      "source": [
        "import datetime\n",
        "\n",
        "# Input start date\n",
        "start_date_str = '05/06/2019 14:00:00'\n",
        "start_date = datetime.datetime.strptime(start_date_str, '%d/%m/%Y %H:%M:%S')\n",
        "\n",
        "# Interval duration\n",
        "interval_duration = datetime.timedelta(minutes=15)\n",
        "\n",
        "# Number of intervals\n",
        "num_intervals = len(loaded_data['series_value'][9])\n",
        "\n",
        "# Calculate the end date\n",
        "end_date = start_date + interval_duration * (num_intervals-1)\n",
        "\n",
        "# Print the end date\n",
        "print(\"End Date:\", end_date.strftime('%d/%m/%Y %H:%M:%S'))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cdf09ce4",
      "metadata": {
        "id": "cdf09ce4"
      },
      "outputs": [],
      "source": [
        "end_date_str = '30/09/2020 23:45:00'\n",
        "\n",
        "# Convert start and end date strings to datetime objects\n",
        "end_date = pd.to_datetime(end_date_str)\n",
        "\n",
        "# Create a column of datetime values between start and end date with a frequency of 15 minutes\n",
        "datetime_column = pd.date_range(start=start_date, end=end_date, freq='15T')\n",
        "\n",
        "#building_0['start_timestamp']=datetime_column\n",
        "solar_3['start_timestamp']=datetime_column"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "1264559d",
      "metadata": {
        "id": "1264559d"
      },
      "outputs": [],
      "source": [
        "solar_3 = solar_3.rename(columns={\"series_name\": \"solar_no\", \"start_timestamp\": \"timestamp\",\"series_value\":\"power_output\"})"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0b812c95",
      "metadata": {
        "id": "0b812c95"
      },
      "outputs": [],
      "source": [
        "solar_3 = solar_3[solar_3.power_output != \"NaN\"]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f9dbf944",
      "metadata": {
        "id": "f9dbf944"
      },
      "outputs": [],
      "source": [
        "solar_3[\"power_output\"] = pd.to_numeric(solar_3[\"power_output\"])\n",
        "solar_3"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "b02a2bcf",
      "metadata": {
        "id": "b02a2bcf"
      },
      "source": [
        "## Solar 4"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6825d75d",
      "metadata": {
        "id": "6825d75d"
      },
      "outputs": [],
      "source": [
        "solar_4 = dataset.loc[dataset['series_name']=='Solar4']\n",
        "solar_4"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "dcd3e0bc",
      "metadata": {
        "id": "dcd3e0bc"
      },
      "outputs": [],
      "source": [
        "import datetime\n",
        "\n",
        "# Input start date\n",
        "start_date_str = '05/06/2019 14:00:00'\n",
        "start_date = datetime.datetime.strptime(start_date_str, '%d/%m/%Y %H:%M:%S')\n",
        "\n",
        "# Interval duration\n",
        "interval_duration = datetime.timedelta(minutes=15)\n",
        "\n",
        "# Number of intervals\n",
        "num_intervals = len(loaded_data['series_value'][10])\n",
        "\n",
        "# Calculate the end date\n",
        "end_date = start_date + interval_duration * (num_intervals-1)\n",
        "\n",
        "# Print the end date\n",
        "print(\"End Date:\", end_date.strftime('%d/%m/%Y %H:%M:%S'))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0ae246cb",
      "metadata": {
        "id": "0ae246cb"
      },
      "outputs": [],
      "source": [
        "end_date_str = '30/09/2020 23:45:00'\n",
        "\n",
        "# Convert start and end date strings to datetime objects\n",
        "end_date = pd.to_datetime(end_date_str)\n",
        "\n",
        "# Create a column of datetime values between start and end date with a frequency of 15 minutes\n",
        "datetime_column = pd.date_range(start=start_date, end=end_date, freq='15T')\n",
        "\n",
        "#building_0['start_timestamp']=datetime_column\n",
        "solar_4['start_timestamp']=datetime_column"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "37f9e7fb",
      "metadata": {
        "id": "37f9e7fb"
      },
      "outputs": [],
      "source": [
        "solar_4 = solar_4.rename(columns={\"series_name\": \"solar_no\", \"start_timestamp\": \"timestamp\",\"series_value\":\"power_output\"})"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "798f3baa",
      "metadata": {
        "id": "798f3baa"
      },
      "outputs": [],
      "source": [
        "solar_4 = solar_4[solar_4.power_output != \"NaN\"]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "494c6884",
      "metadata": {
        "id": "494c6884"
      },
      "outputs": [],
      "source": [
        "solar_4[\"power_output\"] = pd.to_numeric(solar_4[\"power_output\"])\n",
        "solar_4"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "6deee103",
      "metadata": {
        "id": "6deee103"
      },
      "source": [
        "## Solar 5"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b9ba4d65",
      "metadata": {
        "id": "b9ba4d65"
      },
      "outputs": [],
      "source": [
        "solar_5 = dataset.loc[dataset['series_name']=='Solar5']\n",
        "solar_5"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "70b70ec2",
      "metadata": {
        "id": "70b70ec2"
      },
      "outputs": [],
      "source": [
        "import datetime\n",
        "\n",
        "# Input start date\n",
        "start_date_str = '15/01/2019 13:00:00'\n",
        "start_date = datetime.datetime.strptime(start_date_str, '%d/%m/%Y %H:%M:%S')\n",
        "\n",
        "# Interval duration\n",
        "interval_duration = datetime.timedelta(minutes=15)\n",
        "\n",
        "# Number of intervals\n",
        "num_intervals = len(loaded_data['series_value'][11])\n",
        "\n",
        "# Calculate the end date\n",
        "end_date = start_date + interval_duration * (num_intervals-1)\n",
        "\n",
        "# Print the end date\n",
        "print(\"End Date:\", end_date.strftime('%d/%m/%Y %H:%M:%S'))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9346660d",
      "metadata": {
        "id": "9346660d"
      },
      "outputs": [],
      "source": [
        "end_date_str = '30/09/2020 23:45:00'\n",
        "\n",
        "# Convert start and end date strings to datetime objects\n",
        "end_date = pd.to_datetime(end_date_str)\n",
        "\n",
        "# Create a column of datetime values between start and end date with a frequency of 15 minutes\n",
        "datetime_column = pd.date_range(start=start_date, end=end_date, freq='15T')\n",
        "\n",
        "#building_0['start_timestamp']=datetime_column\n",
        "solar_5['start_timestamp']=datetime_column"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "728751cf",
      "metadata": {
        "id": "728751cf"
      },
      "outputs": [],
      "source": [
        "solar_5 = solar_5.rename(columns={\"series_name\": \"solar_no\", \"start_timestamp\": \"timestamp\",\"series_value\":\"power_output\"})"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "263378e0",
      "metadata": {
        "id": "263378e0"
      },
      "outputs": [],
      "source": [
        "solar_5 = solar_5[solar_5.power_output != \"NaN\"]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9961e82c",
      "metadata": {
        "id": "9961e82c"
      },
      "outputs": [],
      "source": [
        "solar_5[\"power_output\"] = pd.to_numeric(solar_5[\"power_output\"])\n",
        "solar_5"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "2f1a4807",
      "metadata": {
        "id": "2f1a4807"
      },
      "source": [
        "## Combining Weather data with our solar dataset"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "029faa75",
      "metadata": {
        "id": "029faa75"
      },
      "source": [
        "### Indexing timestamp"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "98a0a5f8",
      "metadata": {
        "id": "98a0a5f8"
      },
      "outputs": [],
      "source": [
        "solar_0 = solar_0.set_index(pd.DatetimeIndex(solar_0['timestamp'])).drop(solar_0.columns[1], axis=1)\n",
        "solar_0"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "db8c865d",
      "metadata": {
        "id": "db8c865d"
      },
      "outputs": [],
      "source": [
        "solar_1 = solar_1.set_index(pd.DatetimeIndex(solar_1['timestamp'])).drop(solar_1.columns[1], axis=1)\n",
        "solar_1"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b4c1e122",
      "metadata": {
        "id": "b4c1e122"
      },
      "outputs": [],
      "source": [
        "solar_2 = solar_2.set_index(pd.DatetimeIndex(solar_2['timestamp'])).drop(solar_2.columns[1], axis=1)\n",
        "solar_2"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "99a3c5db",
      "metadata": {
        "id": "99a3c5db"
      },
      "outputs": [],
      "source": [
        "solar_3 = solar_3.set_index(pd.DatetimeIndex(solar_3['timestamp'])).drop(solar_3.columns[1], axis=1)\n",
        "solar_3"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "58a1528d",
      "metadata": {
        "id": "58a1528d"
      },
      "outputs": [],
      "source": [
        "solar_4 = solar_4.set_index(pd.DatetimeIndex(solar_4['timestamp'])).drop(solar_4.columns[1], axis=1)\n",
        "solar_4"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c31507d8",
      "metadata": {
        "id": "c31507d8"
      },
      "outputs": [],
      "source": [
        "solar_5 = solar_5.set_index(pd.DatetimeIndex(solar_5['timestamp'])).drop(solar_5.columns[1], axis=1)\n",
        "solar_5"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "e9904430",
      "metadata": {
        "id": "e9904430"
      },
      "source": [
        "### Combining stuff"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "bf4fe2bb",
      "metadata": {
        "id": "bf4fe2bb"
      },
      "outputs": [],
      "source": [
        "weather = pd.read_csv(\"ERA5_Weather_Data_Monash.csv\")\n",
        "weather"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "72d2e00b",
      "metadata": {
        "id": "72d2e00b"
      },
      "outputs": [],
      "source": [
        "weather = weather.set_index(pd.DatetimeIndex(weather['datetime (UTC)'])).drop(weather.columns[0], axis=1)\n",
        "weather"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "da2159c0",
      "metadata": {
        "id": "da2159c0"
      },
      "outputs": [],
      "source": [
        "weather = weather.resample(\"15T\").mean().round(1) #Resampling into 15-minute intervals\n",
        "weather"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0cf260e7",
      "metadata": {
        "id": "0cf260e7"
      },
      "outputs": [],
      "source": [
        "weather.isna().sum()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a01215c4",
      "metadata": {
        "id": "a01215c4"
      },
      "outputs": [],
      "source": [
        "weather = weather.interpolate(method='linear') #Input NaN\n",
        "weather"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4b6f3bb9",
      "metadata": {
        "id": "4b6f3bb9"
      },
      "outputs": [],
      "source": [
        "weather.isna().sum()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "3668e23e",
      "metadata": {
        "id": "3668e23e"
      },
      "outputs": [],
      "source": [
        "weather.index.names = ['timestamp']\n",
        "weather"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5eef6fbf",
      "metadata": {
        "id": "5eef6fbf"
      },
      "outputs": [],
      "source": [
        "solar0 = pd.merge(solar_0, weather, left_index=True, right_index=True)\n",
        "solar0"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5ae258b7",
      "metadata": {
        "id": "5ae258b7"
      },
      "outputs": [],
      "source": [
        "solar1 = pd.merge(solar_1, weather, left_index=True, right_index=True)\n",
        "solar1"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7cbdbf9f",
      "metadata": {
        "id": "7cbdbf9f"
      },
      "outputs": [],
      "source": [
        "solar2 = pd.merge(solar_2, weather, left_index=True, right_index=True)\n",
        "solar2"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "03ce1602",
      "metadata": {
        "id": "03ce1602"
      },
      "outputs": [],
      "source": [
        "solar3 = pd.merge(solar_3, weather, left_index=True, right_index=True)\n",
        "solar3"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "fd1ea2d5",
      "metadata": {
        "id": "fd1ea2d5"
      },
      "outputs": [],
      "source": [
        "solar4 = pd.merge(solar_4, weather, left_index=True, right_index=True)\n",
        "solar4"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9864187c",
      "metadata": {
        "id": "9864187c"
      },
      "outputs": [],
      "source": [
        "solar5 = pd.merge(solar_5, weather, left_index=True, right_index=True)\n",
        "solar5"
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3 (ipykernel)",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.9.7"
    },
    "colab": {
      "provenance": []
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}